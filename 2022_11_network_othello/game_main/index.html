<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>実験C-7 ネットワークプログラミング 実験要領 2022</title>
  <link rel="stylesheet" href="c7.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">実験C-7 ネットワークプログラミング 実験要領 2022</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#目的" id="toc-目的">目的</a></li>
<li><a href="#諸注意必ず実験前に目を通すこと"
id="toc-諸注意必ず実験前に目を通すこと">諸注意（必ず実験前に目を通すこと）</a>
<ul>
<li><a href="#年度の実施形態"
id="toc-年度の実施形態">2022年度の実施形態</a></li>
</ul></li>
<li><a href="#実験計画書について"
id="toc-実験計画書について">実験計画書について</a>
<ul>
<li><a href="#週目" id="toc-週目">1週目</a></li>
<li><a href="#週目-1" id="toc-週目-1">2週目</a></li>
</ul></li>
<li><a href="#配布物" id="toc-配布物">配布物</a></li>
<li><a href="#実験のタスク" id="toc-実験のタスク">実験のタスク</a></li>
<li><a href="#レポートについて"
id="toc-レポートについて">レポートについて</a>
<ul>
<li><a href="#提出物1レポート本体"
id="toc-提出物1レポート本体">提出物1：レポート本体</a></li>
<li><a href="#提出物2ソースコード一式"
id="toc-提出物2ソースコード一式">提出物2：ソースコード一式</a></li>
</ul></li>
<li><a href="#ヒント集" id="toc-ヒント集">ヒント集</a>
<ul>
<li><a href="#配布プログラムについて"
id="toc-配布プログラムについて">配布プログラムについて</a></li>
<li><a href="#タスク1.1エコーサーバクライアントの使い方"
id="toc-タスク1.1エコーサーバクライアントの使い方">タスク1.1：エコーサーバ・クライアントの使い方</a></li>
<li><a href="#タスク1.2telnetを使おうエコー編"
id="toc-タスク1.2telnetを使おうエコー編">タスク1.2：<code>telnet</code>を使おう〜エコー編〜</a></li>
<li><a href="#タスク1.3参照用プログラムreversi-net.jarの使い方"
id="toc-タスク1.3参照用プログラムreversi-net.jarの使い方">タスク1.3：参照用プログラム<code>reversi-net.jar</code>の使い方</a></li>
<li><a href="#タスク1.4telnetを使おうリバーシの手サーバ編"
id="toc-タスク1.4telnetを使おうリバーシの手サーバ編">タスク1.4：<code>telnet</code>を使おう〜“リバーシの手”サーバ編〜</a></li>
<li><a
href="#タスク2リバーシの手プロトコルに従いリバーシの対戦をするクライアントの実装"
id="toc-タスク2リバーシの手プロトコルに従いリバーシの対戦をするクライアントの実装">タスク2：“リバーシの手”プロトコルに従いリバーシの対戦をするクライアントの実装</a></li>
<li><a href="#タスク3リバーシの対戦を行うサーバの実装"
id="toc-タスク3リバーシの対戦を行うサーバの実装">タスク3：リバーシの対戦を行うサーバの実装</a></li>
<li><a href="#タスク4マルチスレッド化"
id="toc-タスク4マルチスレッド化">タスク4：マルチスレッド化</a></li>
<li><a href="#タスク4攻撃に備えよう"
id="toc-タスク4攻撃に備えよう">タスク4：攻撃に備えよう</a></li>
<li><a href="#タスク4aiを作ろう"
id="toc-タスク4aiを作ろう">タスク4：AIを作ろう</a></li>
</ul></li>
<li><a href="#注意点" id="toc-注意点">注意点</a></li>
</ul>
</nav>
<section class="main">
<p id="last_updated">
最終更新：令和4年10月05日(水)
</p>
<p id="author">
文責：松田 一孝
</p>
<ul id="LINKS">
<li class="current">
<a href="./index.html">実験要領</a>
</li>
<li>
<a href="./setup.html">環境の準備</a>
</li>
<li>
<a
href="./connection_via_ssh_forwarding.html">教育用計算機を介した通信</a>
</li>
<li>
<a href="./socket.html">ソケットプログラミング</a>
</li>
<li>
<a href="./protocol.html">“リバーシの手”プロトコル</a>
</li>
</ul>
<h2 id="目的">目的</h2>
<p>ネットワーク対戦型リバーシ（=オセロ）の作成を通して，Socketを利用したTCP/IPプログラミングを実践する．</p>
<h2
id="諸注意必ず実験前に目を通すこと">諸注意（必ず実験前に目を通すこと）</h2>
<!-- ### 全体向け -->
<ul>
<li>本実験では，ネットワーク対戦型リバーシを作成する．</li>
<li>実験計画書作成時の調査が不十分な場合は<em>実験の遂行が困難</em>になりうるので十分に留意すること．（たとえばポインタの知識がなければ実験の遂行は大変になるかもしれない）</li>
<li>ソケットプログラミングについては<a
href="socket.html">別文書</a>を参照のこと．ただし必要な情報は配布ソースコードに含まれている．</li>
<li>コンパイラ（gcc）等の使い方については，本実験で解説することはしない．必要に応じて各自復習しておくこと．</li>
<li>ターミナルエミュレータを用いたコマンドラインI/F上の作業も多いので，復習しておくとよい（たとえば，<code>ls</code>，<code>cd</code>，<code>mv</code>，<code>cp</code>，<code>mkdir</code>，<code>rm</code>，<code>cat</code>，<code>less</code>，<code>ssh</code>や<code>scp</code>などのコマンドなど）．</li>
</ul>
<h3 id="年度の実施形態">2022年度の実施形態</h3>
<p>対面で実施する．ただし，<em>計算機（ノートPC）</em>は持参すること．
また，実施のための環境の設定については<a
href="setup.html">環境の準備</a>を参考に<em>事前に準備</em>すること．</p>
<p>質問等の実験中のコミュニケーションについては対面のほかに，<a
href="https://slack.com">slack</a>を利用する．下記のワークスペース招待URLから東北大のメールアドレスにて参加すること．TAへの質問のみならず，学生同士のコミュニケーションにも活用してほしい．</p>
<p><a
href="https://join.slack.com/t/2022jikken-c7/signup">https://join.slack.com/t/2022jikken-c7/signup</a></p>
<p>軽微な体調不良や経過観察期間等の理由で対面での参加が難しい場合は，それが判明した時点で
<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#106;&#x69;&#x6b;&#x6b;&#x65;&#110;&#x63;&#x2d;&#x37;&#x2d;&#50;&#46;&#x65;&#x63;&#x65;&#x69;&#64;&#x67;&#114;&#112;&#46;&#116;&#x6f;&#104;&#x6f;&#x6b;&#x75;&#46;&#x61;&#x63;&#46;&#106;&#112;" class="email">&#106;&#x69;&#x6b;&#x6b;&#x65;&#110;&#x63;&#x2d;&#x37;&#x2d;&#50;&#46;&#x65;&#x63;&#x65;&#x69;&#64;&#x67;&#114;&#112;&#46;&#116;&#x6f;&#104;&#x6f;&#x6b;&#x75;&#46;&#x61;&#x63;&#46;&#106;&#112;</a>
に速やかに連絡すること．</p>
<!-- #### 出席 -->
<!-- 1週目も2週目についても，*実験開始時に上記Meet会議への参加していることをもって出席とみなす*．遅くとも1，2分前には参加しておくとよい．遅刻した場合はslack経由で担当教員に連絡すること． -->
<!-- ### プログラミングにこだわりのある人向け  -->
<!--   * 演習室のPCを使用すれば実験を遂行することは可能だが，自分のPCを持ち込んで使うことも可能である．ただし，*この文書にアクセス可能なのは学内ネットワークからのみである*．eduroamで接続しているとアクセスできないので，自分のPCを使いたい人は注意すること． -->
<!--   * 本実験は大部分は自宅でも遂行することも可能である．本実験はUnix系のOSで行うことを想定しているが，Windowsユーザは，VirtualBox等を利用することで，LinuxなどのUnix系のOSを用いてプログラミングすることができる． -->
<h4 id="試問">試問</h4>
<p>例年通りの意味での試問は行わない．が，下記の通り実験中に対面で面談を行う．</p>
<h4 id="面談">面談</h4>
<p>実験中に面談を行う（2週目の午後あたり）．面談の目的は，各自の進捗状況を把握し，各タスクを完遂するためのアドバイスをそれに基づき行うことである．（レポート時ではなく）面談時の進捗状況は成績には影響しない．なので，面談においては，進捗状況について気軽に報告・相談してほしい．ただし，面談はあくまでセーフティネット的な位置付けであるので，不明点や質問がある場合は，積極的に早めにTAに聞いてほしい．</p>
<h2 id="実験計画書について">実験計画書について</h2>
<h3 id="週目">1週目</h3>
<p>以下を行い，まとめたものを実験計画書として提出せよ．</p>
<ol type="1">
<li>TCP/IPについて調べ，簡潔（A4半〜1ページ程度）にまとめよ．TCPとUDPの違いについての議論を含めること．</li>
<li>本実験の遂行に必要な知識の確認のため，以下について調べまとめよ．
<ul>
<li>構造体．ポインタ（関数ポインタ含む），<code>malloc</code>および<code>free</code>．</li>
<li><code>make</code>および<code>Makefile</code>．</li>
</ul></li>
</ol>
<h3 id="週目-1">2週目</h3>
<p>2週目の実験計画書の提出は不要である．</p>
<h2 id="配布物">配布物</h2>
<p>以下は，エコーサーバとそのクライアントのプログラム，および実験で拡張する一人用のリバーシのプログラムである．</p>
<ul>
<li><a href="samples_in_c.zip">配布Cプログラムコード</a></li>
</ul>
<p>また，以下は実験タスク3（下記参照）まで実装したjarファイル（Javaのクラスファイルをまとめたもの）である．各自ダウンロードし，自分の作ったプログラムの動作確認等に利用する．
（実験的なWin/Mac用の実行ファイルも後で追加するかもしれない）</p>
<ul>
<li><a href="./reversi-net.jar">参照用プログラム</a></li>
</ul>
<h2 id="実験のタスク">実験のタスク</h2>
<p>本実験は4つのタスクに分かれており，標準ラインは実験タスク３までの完了を想定している．<em>実験タスク２まで完了していない場合，レポートは受けとらない</em>．</p>
<p>具体的な遂行方法はヒント集を参照せよ．また，参照用プログラムと通信を行うには，<a
href="./protocol.html">“リバーシの手”プロトコル</a>に従う必要がある．</p>
<div id="tasks">
<ol type="1">
<li><span class="required">必須</span>ウォームアップ
<ol type="1">
<li>サンプルのエコーサーバとクライアントを動かす</li>
<li><code>telnet</code>コマンドを利用してサンプルのエコーサーバを通信を行う</li>
<li><a href="reversi-net.jar">参照用プログラム</a>を動かす</li>
<li><code>telnet</code>コマンドを利用して，<a
href="reversi-net.jar">参照用プログラム</a>と通信を行う<br />
</li>
</ol></li>
<li><span class="required">必須</span>
リバーシの対戦を行うクライアントの実装</li>
<li><span class="optional">発展</span>
リバーシの対戦を行うサーバの実装</li>
<li><span class="optional">発展</span> 様々な拡張．
<ul>
<li>サーバのマルチスレッド化</li>
<li>より強いAIの搭載</li>
<li>より攻撃に強くする（たとえば，プロトコルに従わないクライアント・サーバとの通信で異常を起こさないようにする）</li>
<li>サーバ同士の対戦の中継を行うプロトコルの設計と実装</li>
<li>その他様々な拡張</li>
</ul></li>
</ol>
</div>
<h2 id="レポートについて">レポートについて</h2>
<!-- 本実験の提出物は３つ（手書きの場合２つ）あり，それぞれ提出方法が違う． -->
<p>本実験の提出物は２つあり，それぞれ提出方法が違う．
<em>どれか１つでも提出が遅れた場合，再提出扱いになるため，忘れずに全て提出すること．</em></p>
<!-- ### 提出物1：紙のレポート -->
<h3 id="提出物1レポート本体">提出物1：レポート本体</h3>
<!-- 他の実験同様，紙のレポートを実験室に提出する．PCで作成した場合には，後述のWeb提出も必須となるので注意すること． -->
<p>ガイダンスで説明された手順に従って，レポートを提出する．
レポートには以下の情報を含めること．<em>以下が含まれていないレポートは受けとらない．</em></p>
<ul>
<li>実験計画書</li>
<li>どのタスクまで行ったか（タスク4まで行った人は具体的に何をしたかも書く）
<ul>
<li>記載例：タスク3まで実施した</li>
</ul></li>
<li>実装方針（アイデア・設計）
<ul>
<li>どのような理由で，コードのどの部分に変更し加えたのか等</li>
</ul></li>
<li>工夫点・改善点
<ul>
<li>工夫点・・・ここを頑張ったというアピールポイント</li>
<li>改善点・・・ここをこうしたらもっと良くなるはずというポイント</li>
</ul></li>
<li>実行結果（実行例等）
<ul>
<li>実行時のターミナルのコピー・スクリーンショット等．</li>
</ul></li>
</ul>
<p>タスク1についてレポート中で言及する必要はない．また，レポートにはソースコードを全て掲載するのではなく，説明で必要な場合に適宜引用すること．</p>
<!-- ### 提出物2：電子的なレポート -->
<!-- 他の実験同様，レポートをPCで作成した人は電子ファイルを提出する．レポート確認用URLから忘れずに提出すること．  -->
<h3 id="提出物2ソースコード一式">提出物2：ソースコード一式</h3>
<p>本実験ではレポートに加えて，<a
href="https://classroom.google.com/">Google
Classroom</a>を通じてソースコード一式（<code>zip</code>もしくは<code>tar.gz</code>形式）も提出すること．提出されたソースコード一式が不完全でコンパイルが通らない場合は，レポートが提出されていない場合と同様に扱う．ソースコード一式には以下を含めること．</p>
<ul>
<li>目的の実行形式を作成するのに必要十分なソースコード</li>
<li><code>Makefile</code>等のビルドスクリプト</li>
<li>ビルド方法や実行方法の説明および変更箇所をまとめたテキストファイル（<code>README</code>や<code>README.md</code>等の命名をすること）</li>
</ul>
<h2 id="ヒント集">ヒント集</h2>
<h3 id="配布プログラムについて">配布プログラムについて</h3>
<ul>
<li>ダウンロードしたらまずはファイルを解凍しよう．homeディレクトリ等に実験C用のディレクトリを作成し，その中に解凍したファイルをまるごと置くとよい．</li>
<li>配布プログラムに同胞されている<code>README</code>をよく読もう．プログラムの使い方はそこに書いてある．</li>
<li><em><code>make doc</code>コマンドを実行することで生成されるドキュメントも参照のこと</em>．ただし，実行には<code>doxygen</code>が必要．</li>
</ul>
<h3
id="タスク1.1エコーサーバクライアントの使い方">タスク1.1：エコーサーバ・クライアントの使い方</h3>
<p>エコーサーバは送られてきたバイトをそのまま送り返す．エコークライアントはユーザの入力をそのままサーバに送り，応答を表示する．</p>
<ol type="1">
<li>配布ソースコードをコンパイルする．</li>
<li>ターミナルを二つ起動し，一方で<code>./echo_server PORT</code>を実行し，エコーサーバを立ち上げる．
<ul>
<li>ここで<code>PORT</code>は65535以下の自然数である．他の人と被らないように選ぶこと．たとえば「60000+学籍番号の下4ケタ」とするなど．</li>
</ul></li>
<li>もう一方のターミナルで<code>./echo_client HOSTNAME PORT</code>を実行し，クライアントを立ち上げる
<ul>
<li>ここで<code>PORT</code>はサーバの起動時に指定した数字と同じもの</li>
<li><code>HOSTNAME</code>は<code>localhost</code>を指定したのでよい．
他のマシンのサーバと通信したい場合はそのマシンに割り当てられているIPアドレス．<code>ifconfig -a</code>で出てくるはず（<code>en0</code>とか<code>en1</code>とかの欄に出てくるはず）．
ただし，同じローカルネットワークに存在するPCでない限りファイアウォール等の理由でまず通信できないので，<a
href="connection_via_ssh_forwarding.html">教育用計算機を介した通信</a>で紹介するsshポートフォワーディング等を利用するとよい．</li>
</ul></li>
<li>クライアントを起動しているターミナルから文字列を送ると，サーバから同じ文字列が返ってくることを確認する．</li>
<li>クライアントを起動する際の<code>HOSTNAME</code>と<code>PORT</code>を適切に指定することで，他のマシンで動作するサーバとも通信する．</li>
</ol>
<p>エンターキーを押すまでクライアントからサーバに文字が送信されないことに気付いた人もいるかもしれない．これは，標準入力が（プログラムではなくシステムによって）バッファリングされているためである．</p>
<!-- <div class="note"> -->
<!-- ### 教育用計算機を介したsshポートフォワーディング -->
<!-- sshポートフォワーディングを使うと，たとえば教育用計算機上で動作するサーバやクライアントと通信することができる． -->
<!-- 以下説明のために教育用計算機のアドレスとして`eiwXX.ec.ecei.tohoku.ac.jp`を使用するが，適宜 -->
<!-- `eiw01.ec.ecei.tohoku.ac.jp`，`eiw02.ec.ecei.tohoku.ac.jp`，`eiw03.ec.ecei.tohoku.ac.jp`のいずれかに読みかえる． -->
<!-- なお，教育用計算機にsshで接続できるのは学内からのみである（TAINS VPNを利用する）． -->
<!-- #### ローカルポートフォワーディング -->
<!-- ```shell  -->
<!-- ssh -L PORT1:DESTINATION:PORT2 sdXXXXX@eiwXX.ec.ecei.tohoku.ac.jp -N  -->
<!-- ``` -->
<!-- とする（`sdXXXXX`の部分は自分のアカウント名に置き換える）と自分のマシン（`localhost`）のポート`PORT1`が教育用計算機（`eiwXX.ec.ecei.tohoku.ac.jp`）からの`DESTINATION`の`PORT2`にフォワードされる（つまり，`localhost`の`PORT1`にアクセスすると教育用計算機上で`DESTINATION`の`PORT2`にアクセスしたことになる）． -->
<!-- なので，たとえば教育用計算機でエコーサーバを`60000`ポートで動かしているときに，自分のマシンで -->
<!-- ```shell  -->
<!-- ssh -L 60000:localhost:60000 sdXXXXX@eiwXX.ec.ecei.tohoku.ac.jp -N  -->
<!-- ``` -->
<!-- をすると， -->
<!-- ```shell -->
<!-- ./echo_client localhost 60000 -->
<!-- ``` -->
<!-- や後述の -->
<!-- ```shell -->
<!-- telnet localhost 60000 -->
<!-- ``` -->
<!-- を実行することで教育用計算機で動くそのサーバと接続することができる． -->
<!-- #### リモートポートフォワーディング -->
<!-- また，自分のマシンで -->
<!-- ```shell  -->
<!-- ssh -R PORT1:DESTINATION:PORT2 sdXXXXX@eiwXX.ec.ecei.tohoku.ac.jp -N  -->
<!-- ``` -->
<!-- を実行することで，教育用計算機からの`DESTINATION`の`PORT1`へのアクセスを自分のマシンのポート`PORT2`へのアクセスへフォワードすることができる． -->
<!-- なので，たとえば自分のマシンで -->
<!-- ```shell  -->
<!-- ssh -R 60000:localhost:60000 sdXXXXX@eiwXX.ec.ecei.tohoku.ac.jp -N  -->
<!-- ``` -->
<!-- を実行し，またエコーサーバをポート`60000`で立ち上げたとする． -->
<!-- そうすると，教育用計算機上で -->
<!-- ```shell -->
<!-- ./echo_client localhost 60000 -->
<!-- ``` -->
<!-- や後述の -->
<!-- ```shell -->
<!-- telnet localhost 60000 -->
<!-- ``` -->
<!-- を実行することであなたのマシンで動くサーバと通信することができる． -->
<!-- #### 組み合わせる -->
<!-- ローカルポートフォワーディングを使うと自分のPCへのアクセスをサーバからのアクセスに置き換えることができ， -->
<!-- リモートポートフォワーディングを使うとサーバからのアクセスを自分のPCへのアクセスに置き換えることができる． -->
<!-- なので，たとえばAさんが -->
<!-- ```shell  -->
<!-- ssh -L 60000:localhost:61111 sdXXXXX@eiwXX.ec.ecei.tohoku.ac.jp -N  -->
<!-- ``` -->
<!-- を実行しBさんが -->
<!-- ```shell  -->
<!-- ssh -R 61111:localhost:62222 sdYYYYY@eiwXX.ec.ecei.tohoku.ac.jp -N  -->
<!-- ``` -->
<!-- を実行することで，Aさんのマシンのポート`60000`が教育用計算機ポート`61111`を経由してBさんのマシンのポート`62222`ヘフォワードされるようになる． -->
<!-- なので，Bさんがたとえば -->
<!-- ``` -->
<!-- ./echo_server 62222 -->
<!-- ``` -->
<!-- でエコーサーバを起動したとすると，Aさんはそのサーバに -->
<!-- ``` -->
<!-- ./echo_client localhost 60000 -->
<!-- ``` -->
<!-- とすることで接続できるようになる． -->
<!-- </div>  -->
<h3
id="タスク1.2telnetを使おうエコー編">タスク1.2：<code>telnet</code>を使おう〜エコー編〜</h3>
<h4 id="telnetとは"><code>telnet</code>とは？</h4>
<p><code>telnet</code>はTelnetと呼ばれるプロトコルを使って通信を行うプログラムである．最近ではTelnetプロトコルはめっきり使われなくなったものの，<code>telnet</code>コマンドはTCP/IPに基づきテキストベースの通信を行う目的で有用である．</p>
<p>より具体的には，<code>telnet</code>により，テキストベースのプロトコルのクライアントの挙動を，手でリクエストを送信することにより確認できる（ことが多い）．</p>
<p>例として，HTTP 0.9というプロトコルを考えてみよう．HTTP
0.9は，現在のウェブで使用されているHTTP
1.1，HTTP/2やHTTP/3と呼ばれるプロトコルの前身にあたるものである．
普段ブラウザを利用して様々なwebページを閲覧していると思うが，それはWebブラウザがHTTP/2等のプロトコルに基づきサーバからそのwebページに関するデータを入手したためである．
<!-- 今読者はこのページをウェブブラウザによって見ていると想定されるが，それはWebブラウザがHTTP 1.1やHTTP/2と呼ばれるプロトコルに基づき，サーバからこのページに関するデータを入手したためである． --></p>
<p>たとえば，コマンドラインから<code>telnet www.ecei.tohoku.ac.jp 80</code>を実行すると</p>
<pre><code>Trying 130.34.41.154...
Connected to eiwww.ecei.tohoku.ac.jp.
Escape character is &#39;^]&#39;.</code></pre>
<p>のような出力が得られる．ここで，素早く<code>GET /</code>と入力して<em>エンターキーを入力</em>すると</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;EUC-JP&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;ja&quot; lang=&quot;ja&quot;&gt;
&lt;head&gt;
...
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>というように，東北大学電気・情報系のwebページのデータが出力される．これはHTTP
0.9というプロトコルに従い，<code>130.34.41.154</code>で動作するwebサーバがポート80に届いた<code>GET /\r\n</code>という要求に対し，電気・情報系のwebページのデータという応答を返したことを意味する．なお，世にwebサーバでは数秒内にリクエストを送信しないと接続が閉じられることが多い．</p>
<h4
id="telnetでエコーサーバと通信する"><code>telnet</code>でエコーサーバと通信する</h4>
<p>HTTPサーバの場合と同様に，配布したエコーサーバも<code>telnet</code>でその応答を確認することができる．例えばポート60000で接続を待ち受けるサーバを起動したとすると，<code>telnet localhost 60000</code>コマンドを実行し，適当に文字入力した後エンタキーを入力してみることを繰り返してみるとよい．エコーサーバの場合は，入力がそのまま出力されることが確認できるだろう．</p>
<ol type="1">
<li>ターミナルを2つ起動し，一方でエコーサーバを立ち上げる．</li>
<li>もう一方のターミナルで<code>telnet localhost PORT</code>を実行する．</li>
<li>要求がそのまま応答として得られることを確認する．</li>
</ol>
<p>別のマシンのエコーサーバと通信してみるのもよい．</p>
<h3
id="タスク1.3参照用プログラムreversi-net.jarの使い方">タスク1.3：参照用プログラム<code>reversi-net.jar</code>の使い方</h3>
<pre><code>java -jar reversi-net.jar server PORT</code></pre>
<p>で起動すると，ポート番号<code>PORT</code>で待ち受ける<a
href="./protocol.html">“リバーシの手”プロトコル</a>のサーバを起動する．<code>PORT</code>は同じマシンにログインしている他の人とかぶらないように選ぶこと（例：「60000+学籍番号の下4ケタ」とするなど）．また，</p>
<pre><code>java -jar reversi-net.jar client HOSTNAME PORT</code></pre>
<p>で起動すると，ポート番号<code>PORT</code>で接続を待ち受けている<code>HOSTNAME</code>にあるサーバに接続するクライアントを起動する．このクライアントはサーバから送られてきた手を反映させた盤面にランダムに合法手を打ち，（終局してなければ）その後の盤面をサーバに送ることを繰り返す．</p>
<p>配布した一人用のリバーシプログラムと同様に対話的に手を入力したい場合は</p>
<pre><code>java -jar reversi-net.jar client -h HOSTNAME PORT</code></pre>
<p>と<code>h</code>を最後につけて実行する．サーバも</p>
<pre><code>java -jar reversi-net.jar server -h PORT</code></pre>
<p>で起動すると，送られてきた盤面に対しユーザに対話的に手を問い合わせ，入力された手をクライアントに送るようになる．（つまり，「あなた」がサーバの中の人になる．）</p>
<p><code>reversi-net.jar</code>と正常に通信が行えるかどうかを確認するのは，各タスクで実装するプログラムの動作確認に役立つかもしれない．</p>
<h3
id="タスク1.4telnetを使おうリバーシの手サーバ編">タスク1.4：<code>telnet</code>を使おう〜“リバーシの手”サーバ編〜</h3>
<p><a
href="./protocol.html">“リバーシの手”プロトコル</a>のサーバについても，telnetで応答を確認することができる．</p>
<ol type="1">
<li>ターミナルを2つ起動し，一方で”リバーシの手”プロトコルのサーバを立ち上げる．</li>
<li>もう一方のターミナルでtelnet localhost PORTを実行する．</li>
<li>プロトコルに従ったリクエスト文字列を送り，動作を確認する．</li>
</ol>
<p>たとえば</p>
<pre><code>MOVE O-XXXXXXOOXXOOXXOOOOOOOXXOXOXXOXXOOXOOOOXOXOXX-OXXOXXXXXXXX-OO-X X</code></pre>
<p>と入力してエンターを押すと，</p>
<pre><code>B1</code></pre>
<p>のような出力が得られることだろう．</p>
<h3
id="タスク2リバーシの手プロトコルに従いリバーシの対戦をするクライアントの実装">タスク2：“リバーシの手”プロトコルに従いリバーシの対戦をするクライアントの実装</h3>
<p>聡明な学生は，一人用のリバーシのプログラムにエコークライアントの処理の一部を拡張して組み合わせることでリバーシの対戦を行うクライアントを作成することができることに気づいているかもしれない．
一人用のリバーシは，現在の盤面が与えられると，その盤面に応じた合法手の中からランダムな手を打つ．その部分を，現在の盤面（と手番）を”リバーシの手”プロトコルに従いサーバに送りその応答のまま手を打つように変えればよい．</p>
<p>盤面に対して如何に手を打つか，すなわち与えられた盤面に基づいてどうプレイするかは，配布プログラムでは<em>プレイヤー</em>として抽象化されている．具体的には，<code>player_t</code>構造体を用いてプレイヤーを表現している．一人用のリバーシだと，ランダムに手を打つプレイヤーは，<code>player.c</code>の<code>make_random_player</code>関数で作成する．</p>
<p>なので，
実装するにあたり，<em>配布したプログラムのほとんどは変更を加える必要がない</em>ことに気付くかもしれない．
まずは以下の２点について調べるとよいだろう．</p>
<ul>
<li>エコークライアントプログラムの中で，どの部分が文字列の送受信をしているのか．</li>
<li>一人用のリバーシのランダムプレイヤーはどのように実装されているのか．</li>
</ul>
<p>具体的な方針としては，<code>player.c</code>に<code>struct player_t* make_remote_player(const char* host, const char* port)</code>という関数を実装するとよいだろう．<code>make_remote_player(host, port)</code>は，指定された<code>host</code>と<code>port</code>に接続をした後，<code>player_t</code>構造体へのポインタを返す．この構造体の<code>play</code>はサーバに手を問い合わせを行いその手を返すこととなるだろう．適宜試合終了後に接続を閉じるのを忘れてはいけない．</p>
<!-- 元のコードと分けるために，`net`というサブディレクトリを作成し，そこに新しく書くコードをまとめるとよいだろう（ただしCだと`Makefile`の修正も必要となってしまう，Javaだとパッケージの管理に注意）． -->
<p>元のコードと今回新しく作成したコードを分けるために，ファイル名に適当な接頭辞を付けたり，新しいコードを適当なサブディレクトリ（たとえば<code>net</code>等）の下にまとめたりするとよいだろう．後者のほうが「丁寧な」アプローチかもしれないが，<code>Makefile</code>等の修正が必要ない分前者のほうが楽かもしれない．</p>
<p>あとは適切なプレイヤーを<code>main</code>関数から利用すればよい．</p>
<h3
id="タスク3リバーシの対戦を行うサーバの実装">タスク3：リバーシの対戦を行うサーバの実装</h3>
<p>ノーヒントとする．敢えて言うとしたら，プレイヤー（<code>struct player_t</code>型の値や<code>Player</code>型のオブジェクト）はサーバの「中の人」として，ここでも利用することになるだろう．</p>
<h3 id="タスク4マルチスレッド化">タスク4：マルチスレッド化</h3>
<p>サーバをマルチスレッド化することで，複数のクライアントと同時通信を行うことが可能となる．
ところで，配布されたエコーサーバは複数のクライアントとの通信が可能なものも含まれている．</p>
<h3 id="タスク4攻撃に備えよう">タスク4：攻撃に備えよう</h3>
<p>サーバに接続しているクライアント，クライアントが接続するサーバは常にプロトコロルに従っているとは限らない．むしろ，相手のマシンをダウンさせてやろう，乗っとてやろうという攻撃者が存在するというのが現状だ．以前の研究室で私（松田）がsshでログイン可能なサーバを立てたところ，不正なログインの試みが数千件/日ほどあり，またその他の攻撃も一日数10件程度発生した．サーバを立てて公開するというのは攻撃にさらされるということは理解しておいたほうがよい．</p>
<p>さて，本プロトコロルに従うサーバ（クライアント）であるが，以下のような攻撃が考えられるだろう．</p>
<ul>
<li>バッファオーバフローやサーバのダウンを狙い不正なバイト列を送りつける．</li>
<li>DoS攻撃として，大量の接続を試みる．</li>
</ul>
<p>バッファオーバフローはCだと特に気をつけるべきであろう．ここでは詳細は述べないが，バッファオーバフローは任意プログラム実行等につながりうる重大なセキュリティホールの一つである．また，プロトコルに従った要求や応答が<code>\r\n</code>終端であるといっても，<code>\r\n</code>を見つけるまで<code>read</code>を繰り返すプログラム（<code>fscanf</code>を用いたりするなど）は<code>\r\n</code>を含まない長大なバイト列が送信されてくると，いずれメモリ不足でプログラムが異常終了することとなるだろう．</p>
<p>DoS攻撃については，そもそも本プロトコルはDoS攻撃にあまり強いものではない（特に人同士を対戦を考えると接続を長時間維持する必要があり，AIで「手」を選ぶことを考えるとそもそも高負荷になりがちなので）．それにDoS攻撃はサーバプログラムよりも前のレベル，FWやプロバイダレベルで対処する必要があり，サーバプログラムできることは少ない．</p>
<p>また，サーバプログラムはリソースリークには気をつけるべきである．リソースリークがあれば正常な接続を繰り返すだけでいずれサーバが正常に動作しなくなる．今回，気をつけるべきリソースは</p>
<ul>
<li>メモリ（特にCの場合は<code>malloc</code>したものを<code>free</code>するのを忘れない）</li>
<li>ファイル記述子（ソケットは必ずいずれクローズするように）</li>
<li>スレッド</li>
</ul>
<p>等だろうか．適当にサーバに負荷をかけてみるとよい．Cであればvalgrind等の利用も考慮すべし．</p>
<p>なお，配布プログラムは</p>
<pre><code>java -jar reversi-net.jar client -q -n NUM HOSTNAME PORT</code></pre>
<p>のように起動するとクライアントを<code>NUM</code>個並行に実行する．</p>
<h3 id="タスク4aiを作ろう">タスク4：AIを作ろう</h3>
<p>リバーシは一つの盤面ごとの合法手の数が少ない．そのため，かなり先の手まで現実的な時間で読むことができる．このことは，終盤は終局まで読み切ることを可能とする．</p>
<p>中盤では終局まで読みきることは難しい．そのため探索を途中で打ち切って盤面の価値を判断し，相手がどんな手を打とうとも「よい」盤面に辿りつく手を打つことがよく行われている．「リバーシ
評価関数」や「α-β探索」等について調べるとよい．</p>
<p>序盤は定石に従ってプレイするのが定石である．これは，まだあまり石が置かれてないような序盤の盤面に対しては，評価関数があまりよい指標とならないことが多いためである．リバーシには様々な定石が知られているので調べてみるのもよいかもしれない．</p>
<p>また，「モンテカルロ木探索」と呼ばれるアルゴリズムがあり，囲碁のAI等で利用されている．これについて調べみるのもよいだろう．</p>
<h2 id="注意点">注意点</h2>
<ul>
<li>1分考えて何をすべきかわからなかったら，あるいは5分考えてどうしてよいかわからなかったら，<em>TAに積極的に質問しましょう</em>．
<ul>
<li>（2021年注）特にオンラインだとTAからはあなたの手が止まっているかどうかを知るすべはない．積極的に助けをもとめよう．</li>
<li>そうでなくても，ちょっとでも気になったことがあったらどんどん質問しよう．</li>
</ul></li>
<li>（特に講義時間外に）「うまくいかないこと」について質問するときには，TAが問題を再現できるようにSlackにコード一式等も添付するとよい．</li>
<li>配布プログラムの<code>README</code>は読みましょう．</li>
<li><code>make doc</code>を実行した結果として生成されるドキュメントも読みましょう．</li>
<li>こまったらCなら<code>man</code>コマンドを使おう．システムコールは<code>man 2</code>，Cの関数は<code>man 3</code>を使おう．たとえば，<code>man 3 printf</code>とすると<code>printf</code>関数の説明が表示される．</li>
<li><code>send</code>あるいは<code>write</code>で送ったデータがそのまま一つのパケットして転送されるとは限らない．複数のパケットに分割されたり，あるいは短い時間連続した<code>write</code>をOSがまとめて送信することはある．</li>
<li>（特にソケットに対する）<code>write</code>は書こうとしたバイト数が必ずかかれるわけではなく，<code>read</code>も指定されたバイト数を必ず読みとれるわけではない．エラー以外の理由でこれらの発生を避けたければ，<code>fdopen</code>をして<code>fread</code>や<code>fwrite</code>を使用しよう．</li>
<li><code>fread</code>や<code>fwrite</code>を使う場合はバッファリングに気をつけよう．<code>setbuf</code>や<code>fflush</code>を使用する？</li>
<li><code>read</code>が<code>0</code>を返したらば，その接続が相手から閉じられたということ．</li>
<li><code>strcmp</code>や<code>strcat</code>を使用する必要はないはずだ．<code>memmove</code>や<code>memset</code>ならば使う人もいるかもしれない．</li>
<li>ドキュメントの<code>board.h</code>や<code>ReversiBoard</code>のあたりもよく読もう．通信に便利な関数が見つかるかもしれない．</li>
<li>エラーコードをチェックしよう．たとえば<code>perror</code>や<code>strerror</code>等を活用しよう．
<!--  * Javaだと`Socket`の`getInputStream()`や`getOutputStream()`で得られるストリームはJavaレベルではバッファされない．--></li>
<li>プログラムの改変に関数ポインタの知識が必要．
<!-- * Javaだと，プログラムの改変にクラスや継承の知識が必要． --></li>
<li>学外から学内の友人のプログラムと通信しようとするのはファイアウォールがあるので難しい．</li>
<li>スレッドを他スレッドから<code>Thread.stop</code>や<code>pthread_cancel</code>で止めようとするのはよい考えではない．</li>
<li><code>BufferedReader.readLine</code>とか<code>getline</code>とかを利用すると楽かもしれない．ただし悪意のあるクライアントは改行文字を送信しないかもしれないことに留意する．</li>
<li>（自分が設置したものではない）外部のサーバに対しプロトコルの仕様に沿わない通信を行おうと試みることは最悪の場合犯罪とみなされることがある．絶対にやらないこと．</li>
</ul>
</section>
</body>
</html>
